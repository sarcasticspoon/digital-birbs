Part 1 Concurrency:
We implemented concurrency by keeping a ready queue of processes and a current process pointer. Each process is represented by a process_t struct that saves the current stack pointer for that process and a pointer to the next process in the queue. 

In the setup function of the main program, we call process_create() with a function to create a new process. process_create() mallocs space for a new process_t struct, calls process_init() to set up the stack for the process, and adds the new process_t to the head of the ready queue. In the loop function, we call process_start(), which initializes the current_process to NULL and calls process_begin(). This function calls process_select() with 0 as the cursp, and process_select() pops the head off the ready queue and sets that process to the current process, returning its stack pointer. 

When the timer interrupt occurs, the handler calls yield(), which calls process_select() with the current stack pointer. process_select() saves the current stack pointer into the current process and adds the current process to the end of the ready queue. It pops the head off and returns the sp as described above. When a process terminates, process_select() only returns the head; when the queue is empty, process_select() continues with the current process, eventually returning to the main program. 

Other comments: For some reason, this code only worked on a Windows machine. When run on a Mac, P2 and P3 in test2 do not run to completion, and interleave after every line. Instead, it appears that the processes run for a few time slices, and then the setup() function in the main process runs again and resets all the processes. We talked to Kasey about this, and have yet to find a solution. Some sample output is given below: 
