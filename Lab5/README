Part 2: Implemented condition variables associated with a lock and a waiting queue of processes, and implicitly (by programmer use) a condition. The cv contains a pointer to a lock and a pointer to a process that forms the head of processes waiting on the cv. When a process calls cond_wait, the cv checks to see if the lock passed in matches its lock, and if so, puts the process on the back of its waiting queue and sets the process' is_waiting variable to 1. When the current process switches out in process_select, the is_waiting variable tells the function not to add the process to the ready queue again as it would normally. 
In cond_signal, the cv wakes up the next process on the waiting queue of the condition variable by putting it back onto the ready queue (calling process_add to do so). It does not release the lock so ownership of the lock passes to the woken up process and ensures that no other process gets the lock. 
Test cases: we tested this part by using the reader/writer problem. In test1, there can only be one user at time acccessing the shared book variable. In all other tests, readers must wait until there are no writers, and writers must wait until there are no users (writers or readers) before modifying the variable. Multiple readers may access the variable at the same time, but there may not be multiple writers. 

Part 3: Scheduling 
Implemented priority scheduling and real time scheduling. 
When creating a job with a priority, all jobs are assigned a default priority of 128. The job is added to the ready queue after a job with a higher priority and before a job with a lower priority (edge cases accounted for). In process_select(), if the next job in the queue has a lower priority, the current job simply continues executing because all jobs in the ready queue are ordered in order of decreasing priority. If the next job in the queue has the same priority, we add the current process just behind the last process in the queue that has the same priority (the block of processes with the same priority) so these processes are scheduled round-robin. 
Real time jobs have the highest priority, 0, and will always be placed at the head of the ready queue. When process_create_rtjob() is called, it creates a process_t struct with an absolute deadline (the current millis() value + the relative deadline given). Then, it places the process in the block of real time jobs in the ready queue in order of earliest deadline first. It evalutes the feasibility of the schedule by considering just the first process in the queue and seeing if the wcet if this process + the current start time exceeds that process' absolute deadline. If it does, we consider the schedule composed of the first and second processes by incrementing the start time by the wcet of the previous process and then comparing start + wcet to the deadline of the second process. This continues until all realtime are put back into the schedule. If at any point, the schedule is infeasible, we remove the most recently added job and return. 
In process_select(), we update the start property of real time jobs by assigning it the current value of millis(). Then when the process terminates, we compare the current time to this stored start time to derive the actual execution time, reporting the difference between the actual et and the wcet. If the process missed its deadline, we compare the difference in deadlines to the difference in execution times; if the process was slower than expected by a value greater than the difference in deadlines, then we report that the process missed its deadline because of an incorrect wcet.
